% !TEX root = ../my-thesis.tex
%
\chapter{Appendix}
\label{sec:appendix}
\section{Probability Distributions}
\subsection{The Normal Distribution}
The normal distribution is an important type of continuous probability distribution in stochastics. The special significance of the normal distribution is based, among other things, on the central limit theorem, according to which distributions that result from the additive combination of a large number of independent influences are approximately normally distributed under weak conditions. \\
The density is given by
\begin{equation}
    f\left(\pmb{x}|\mu,\sigma\right)=\frac{1}{\sigma\sqrt{2\pi}}\exp\left(-\frac{1}{2}\left(\frac{\pmb{x}-\mu}{\sigma}\right)^2\right).
\end{equation}
The first two moments of the distribution are given by
\begin{align}
    \mathbb{E}\left[X\right] &= \mu \\
    \hbox{Var}\left[X\right] &= \sigma^2.
\end{align}
The graph of this density function has a "bell-shaped form" and is symmetrical with $\mu$ as the centre of symmetry \autocite[][83-85]{fahrmeir2016statistik}.
\subsection{The Poisson Distribution}
The Poisson distribution is a discrete probability distribution that can be used to model the number of events that occur independently of each other at a constant mean rate in a fixed time interval or spatial area. \\
The density is given by
\begin{equation}
    f\left(k\right)=\mathbb{P}\left(X=k\right)=\begin{cases}
    \frac{\lambda^k}{k!}\exp\left(-\lambda\right) & \hbox{for }x\in\left\lbrace0,1,...\right\rbrace \\
    0 & \hbox{else}
    \end{cases}
\end{equation}
with $\lambda$ representing the expected value of $X$.  \\
The first two moments of the distribution are given by
\begin{align}
    \mathbb{E}\left[X\right] &= \lambda \label{eq:poisson_exp}\\
    \hbox{Var}\left[X\right] &= \lambda \label{eq:poisson_var}.
\end{align}
For $\lambda\geq10$ the distribution becomes approximately symmetrical and can thus be approximated by a normal distribution \autocite[][243]{fahrmeir2016statistik}.
\subsection{The Negative Binomial Distribution}
The negative binomial distribution is a univariate probability distribution that belongs to the discrete probability distributions. It models the number of trials required to achieve a given number of successes in a Bernoulli process. \\
The density is given by
\begin{equation}
    f\left(k,r,p\right)=\mathbb{P}\left(X=k\right)=\begin{pmatrix} k+r-1\\r-1\end{pmatrix}\left(1-p\right)^kp^r,
\end{equation}
with $r$ the number of successes, $k$ the number of failures, and $p$ the probability of success. \\
The first two moments of the distribution are given by
\begin{align}
    \mathbb{E}\left[X\right] &= \frac{pr}{1-p} \\
    \hbox{Var}\left[X\right] &= \frac{pr}{\left(1-p\right)^2}.
\end{align} 
For large values of $r$, the negative binomial distribution can be approximated by a normal distribution
\cite{haldane1941fitting}.
\clearpage
\section{Distribution Fits}
\subsection{Distribution Fits for Germany}
\begin{figure}[H]
    \centering
    \includegraphics[width = 0.8\textwidth]{fit_normal_germany.png}
    \caption{A normal fit to the number of cases in German municipalities}
    \label{fitNormalGermany}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width = 0.8\textwidth]{fit_poisson_germany.png}
    \caption{A Poisson fit to the number of cases in German municipalities}
    \label{fitPoissonGermany}
\end{figure}
\subsection{Distribution Fits for Norway}
\begin{figure}[H]
    \centering
    \includegraphics[width = 0.8\textwidth]{fit_normal_norway.png}
    \caption{A normal fit to the number of cases in Norwegian municipalities}
    \label{fitNormalNorway}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width = 0.8\textwidth]{fit_poisson_norway.png}
    \caption{A Poisson fit to the number of cases in Norwegian municipalities}
    \label{fitPoissonNorway}
\end{figure}
\clearpage
\section{Choice of Hyperpriors for Germany}
\begin{figure}[H]
    \centering
    \includegraphics[width = \textwidth]{comparison_1_germany.png}
    \caption{Values of the DIC and the WAIC when changing the value for $\sigma_0$. The black line highlights the values for $\sigma_0$ = 1.}
    \label{comparison_germany_1}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width = \textwidth]{mae_germany.png}
    \caption{Values of the MAE when changing the value for $\sigma_0$. The black line highlights the values for $\sigma_0$ = 1.}
    \label{comparison_germany_2}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width = \textwidth]{spatial_field_germany_1.png}
    \caption{Spatial field for a Besag model and a Leroux model.}
    \label{comparison_germany_6}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width = \textwidth]{spatial_field_germany_2.png}
    \caption{Spatial fields for a BYM2 model.}
    \label{comparison_germany_7}
\end{figure}
\clearpage
\section{Code Examples}
\subsection{Specifying the Different Types of Models}
\begin{lstlisting}[caption={Specifying different models in INLA.}, label={codeModels}, language=R]
# set the seed
set.seed(420)
# draw a sample
test <- sample(
    seq_len(nrow(newest_numbers)),
    size = floor(0.2 * nrow(newest_numbers))
  )
# get the number of infections for the test data
test_value <- newest_numbers$value[test]
# set the number of infections to NA in the train data
newest_numbers$value[test] <- NA
# define the link function
link <- rep(NA, nrow(newest_numbers))
link[which(is.na(newest_numbers$value))] <- 1
# for the temporal model every 5th day is taken
germany <- germany[
  germany$Date %in% seq(
    from = min(germany$Date),
    to = max(germany$Date),
    by = 5
  ),
]
# draw a sample
test_temporal <- sample(
  seq_len(nrow(germany)),
  size = floor(0.2 * nrow(germany))
)
test_value_temporal <- germany$value[test_temporal]
germany$value[test_temporal] <- NA
link_temporal <- rep(NA, nrow(germany))
link_temporal[which(is.na(germany$value))] <- 1
# define the penalised prior
prior_1 <- list(
  prec = list(
    prior = "pc.prec",
    param = c(1, 0.01)
  )
)
# create the neighbordhood matrix
nb <- poly2nb(newest_numbers)
# save the matrix
nb2INLA("maps/map.adj", nb)
g <- inla.read.graph(filename = "maps/map.adj")
# define the C matrix for the Leroux model
Q <- Diagonal(x = sapply(nb, length))
for (i in 2:nrow(newest_numbers)) {
  Q[i - 1, i] <- -1
  Q[i, i - 1] <- -1
}

C <- Diagonal(x = 1, n = nrow(newest_numbers)) - Q
# formula for the model without the spatial component
formula_1 <- value ~
  pop_dens + urb_dens + sex + trade_tax + SPD + Gruene + FDP +
  die_linke + clinic + place_of_worship + nursing_home +
  aerodrome + platform + office + marketplace + higher_education
# formula for the besag model
formula_2 <- value ~
  pop_dens + urb_dens + sex + trade_tax + SPD + Gruene + FDP +
  die_linke + clinic + place_of_worship + nursing_home +
  aerodrome + platform + office + marketplace + higher_education +
  f(idarea_1, model = "besagproper", graph = g, hyper = prior_1)
# formula for the bym2 model
formula_3 <- value ~
  pop_dens + urb_dens + sex + trade_tax + SPD + Gruene + FDP +
  die_linke + clinic + place_of_worship + nursing_home +
  aerodrome + platform + office + marketplace + higher_education +
  f(
    idarea_1, model = "bym2", graph = g,
    scale.model = TRUE, hyper = prior_1
  )
# formula for the leroux model
formula_4 <- value ~
  pop_dens + urb_dens + sex + trade_tax + SPD + Gruene + FDP +
  die_linke + clinic + place_of_worship + nursing_home +
  aerodrome + platform + office + marketplace + higher_education +
  f(idarea_1, model = "generic1", Cmatrix = C, hyper = prior_1)
# formula for the temporal bym2 model
formula_5 <- value ~
  pop_dens + urb_dens + sex + trade_tax + SPD + Gruene + FDP +
  die_linke + clinic + place_of_worship + nursing_home +
  aerodrome + platform + office + marketplace + higher_education +
  f(
    idarea_1, model = "bym2", graph = g,
    scale.model = TRUE, hyper = prior_1
  ) +
  f(id_date_1, model = "rw2", hyper = prior_1)
# compute the models
# for the non-temporal models the code looks like this
res_1 <- inla(
  formula_1,
  family = "nbinomial",
  data = newest_numbers,
  E = expected_count,
  control.predictor = list(
    compute = TRUE,
    link = link
  ),
  Ntrials = newest_numbers$population,
  control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE)
)
# for the temporal models the code looks like this
res_5 <- inla(
  formula_5,
  family = "nbinomial",
  data = germany,
  E = expected_count,
  control.predictor = list(
    compute = TRUE,
    link = link_temporal
  ),
  Ntrials = germany$population,
  control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE)
)
\end{lstlisting}
\subsection{Making Predictions for the Test Data}
\begin{lstlisting}[caption={The code for making predictions in INLA.}, label={codePrediction}, language=R]
# create a vector to save the predictions to
predicted_1 <- c()
predicted_2 <- c()
# make predictions for a non-temporal model
for (i in seq_len(nrow(newest_numbers))) {
  predicted_1[i] <- inla.emarginal(
    function(x) x * newest_numbers$population[i],
    res_1$marginals.fitted.values[[i]]
  )
}
# calculate the mae
mean(abs(predicted_1[test] - test_value)),
# make predictions for a temporal model
for (i in seq_len(nrow(germany))) {
  predicted_2[i] <- inla.emarginal(
    function(x) x * germany$population[i],
    res_5$marginals.fitted.values[[i]]
  )
}
# calculate the mae
mean(abs(predicted_2[test_temporal] - test_value_temporal)),
\end{lstlisting}
\subsection{Calculating the Posterior Mean}
\begin{lstlisting}[caption={Calculating the posterior mean of a coefficent.}, label={codePosteriorMean}, language=R]
inla.emarginal(
      exp,
      res_1$marginals.fixed$`(Intercept)`
)
\end{lstlisting}
\subsection{Calculating a Credibility Interval}
\begin{lstlisting}[caption={Extracting the credibility interval for a coefficient}, label={codeCredibility}, language=R]
inla.qmarginal(
      c(0.025, 0.975),
      inla.tmarginal(
        exp,
        res_1$marginals.fixed$`(Intercept)`
      )
)
\end{lstlisting}
\subsection{Calculating the Temporal Trend}
\begin{lstlisting}[caption={Calculating the Temporal Trend of a Model}, label={codeTemporal}, language=R]
temporal_car <- lapply(
  res_5$marginals.random$id_date_1,
  function(x) {
    marg <- inla.tmarginal(
      function(y) exp(y),
      x
    )
    inla.emarginal(mean, marg)
  }
)
\end{lstlisting}
\clearpage